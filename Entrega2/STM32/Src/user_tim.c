#include <stdint.h>
#include "main.h"
#include "user_tim.h"

void USER_TIM3_PWM_Init( void ){
	// Enable the clock signal for the TIM3 and GPIOB peripherals
	RCC->IOPENR		|=  ( 0x1UL <<  1U );
	RCC->APBENR1	|=  ( 0x1UL <<  1U );

	// Configure TIM3_CH1 (PB4) to output the PWM signal
	GPIOB->AFRL		&= ~( 0xEUL << 16U );
	GPIOB->AFRL		|=  ( 0x1UL << 16U );
	GPIOB->PUPDR  &= ~( 0x3UL <<  8U );
	GPIOB->OTYPER	&= ~( 0x1UL <<  4U );
	GPIOB->MODER  &= ~( 0x1UL <<  8U );
	GPIOB->MODER  |=  ( 0x2UL <<  8U );

	// Configure the clock source (internal)
	TIM3->SMCR		&= ~( 0x1UL << 16U )
								&  ~( 0x7UL <<  0U ); // Prescaler is clocked directly by the internal clock

	// Configure the counter mode, the auto-reload and the overflow UEV-event
	TIM3->CR1			&= ~( 0x3UL <<  5U ) // Selects edge-aligned mode
								&  ~( 0x1UL <<  4U ) // Counter used as upcounter
								&  ~( 0x1UL <<  2U ) // UEV can be generated by software
								&  ~( 0x1UL <<  1U );// Update Event (UEV) enabled
	TIM3->CR1			|=  ( 0x1UL <<  7U ); // Auto-reload register is buffered

	// Configure the prescaler, the period and the duty cycle register values
	TIM3->PSC			 = 0U;
	TIM3->ARR			 = 47999U; // for 1 KHz frequency
	TIM3->CCR1		 = USER_Duty_Cycle( 10 ); // for 25% of duty cycle

	// Configure the PWM mode, the compare register load and channel direction
	TIM3->CCMR1		&= ~( 0x1UL << 16U )
								&  ~( 0x1UL <<  4U ) // Selects PWM 1 mode
								&  ~( 0x3UL <<  0U ); // Selects CH1 as output

	TIM3->CCMR1		|=  ( 0x6UL <<  4U ) // Selects PWM 1 mode
								|   ( 0x1UL <<  3U ); // CCR1 loads on the UEV event

	// Generate the UEV-event to load the registers
	TIM3->EGR			|=  ( 0x1UL <<  0U );

	// Enable the PWM signal output and set the polarity
	TIM3->CCER		&= ~( 0x1UL <<  3U ) // For output mode, this bit must be cleared
								&  ~( 0x1UL <<  1U ); // OC1 active high
	TIM3->CCER		|=  ( 0x1UL <<  0U ); // OC1 signal is output on the corresponding pin

	// Enable the Timer to start counting
	TIM3->CR1			|=  ( 0x1UL <<  0U );
}

void update_cycle(uint8_t duty){
	// Update the duty cycle value
	TIM3->CCR1		 = USER_Duty_Cycle( duty );
}

uint16_t USER_Duty_Cycle( uint8_t duty ){
	// duty can be a value between 0% and 100%
	if( duty <= 100 )
		return (( duty / 100.0 )*( TIM3->ARR + 1));
	else
		return 0;
}

void USER_TIM3_Delay( uint16_t prescaler, uint16_t maxCount ){
	// Configure the prescaler and the maximum count
	TIM3->PSC = prescaler;
	TIM3->ARR = maxCount;
	// Clear the Timer Update Interrupt Flag
	TIM3->SR &= ~( 0x1UL << 0U );
	// Enable the Timer to start counting
	TIM3->CR1 |= ( 0x1UL << 0U );
	// Wait for the Overflow
	while(!(TIM3->SR & ( 0x1UL << 0U )));
	// Disable the Timer to stop counting
	TIM3->CR1 &= ~( 0x1UL << 0U );
}