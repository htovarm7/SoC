#include <stdint.h>
#include "main.h"
#include "user_tim.h"

void USER_TIM3_Init( void ){
	RCC->APBENR1	|=  ( 0x1UL <<  1U );
	TIM3->SMCR		&= ~( 0x1UL << 16U )
					&  ~( 0x7UL <<  0U );
	TIM3->CR1		&= ~( 0x1UL <<  7U )
					&  ~( 0x3UL <<  5U )
					&  ~( 0x1UL <<  4U )
					&  ~( 0x1UL <<  1U );
}

//void USER_TIM3_PWM_Init( void ){
//	/* STEP 0. Enable the clock signal for the TIM3 and GPIOB peripherals */
//	RCC->IOPENR		|=  ( 0x1UL <<  1U );
//	RCC->APBENR1	|=  ( 0x1UL <<  1U );
//
//	/* STEP 0. Configure TIM3_CH1 (PB4) to output the PWM signal */
//	GPIOB->AFRL		&= ~( 0xEUL << 16U );
//	GPIOB->AFRL		|=  ( 0x1UL << 16U );
//	GPIOB->PUPDR  &= ~( 0x3UL <<  8U );
//	GPIOB->OTYPER	&= ~( 0x1UL <<  4U );
//	GPIOB->MODER  &= ~( 0x1UL <<  8U );
//	GPIOB->MODER  |=  ( 0x2UL <<  8U );
//
//	/* STEP 1. Configure the clock source (internal) */
//	TIM3->SMCR		&= ~( 0x1UL << 16U )
//								&  ~( 0x7UL <<  0U );//		Prescaler is clocked directed by the internal clock
//
//	/* STEP 2. Configure the counter mode, the auto-reload and the overflow UEV-event  */
//	TIM3->CR1			&= ~( 0x3UL <<  5U ) //		Selects edge-aligned mode
//								&  ~( 0x1UL <<  4U ) //		Counter used as upcounter
//								&  ~( 0x1UL <<  2U ) //		UEV can be generated by software
//								&  ~( 0x1UL <<  1U );//		Update Event (UEV) enabled
//	TIM3->CR1			|=  ( 0x1UL <<  7U );//		Auto-reload register is buffered
//
//	/* STEP 3. Configure the prescaler, the period and the duty cycle register values */
//	TIM3->PSC			 = 0U;
//	TIM3->ARR			 = 47999U;//	for 1 KHz frequency
//	TIM3->CCR1		 = USER_Duty_Cycle( 25 );//	for 25% of duty cycle
//
//	/* STEP 4. Configure the PWM mode, the compare register load and channel direction */
//	TIM3->CCMR1		&= ~( 0x1UL << 16U )
//								&  ~( 0x1UL <<  4U ) //		Selects PWM 1 mode
//								&  ~( 0x3UL <<  0U );//		Selects CH1 as output
//
// 	TIM3->CCMR1		|=  ( 0x6UL <<  4U ) //		Selects PWM 1 mode
//								|   ( 0x1UL <<  3U );//		CCR1 loads on the UEV event
//
//	/* STEP 5. Generate the UEV-event to load the registers */
//	TIM3->EGR			|=  ( 0x1UL <<  0U );
//
//	/* STEP 6. Enable the PWM signal output and set the polarity */
//	TIM3->CCER		&= ~( 0x1UL <<  3U ) //		for output mode, this bit must be cleared
//								&  ~( 0x1UL <<  1U );//		OC1 active high
//	TIM3->CCER		|=  ( 0x1UL <<  0U );//		OC1 signal is output on the corresponding pin
//
//	/* STEP 7. Enable the Timer to start counting */
//	TIM3->CR1			|=  ( 0x1UL <<  0U );
//}
//
//uint16_t USER_Duty_Cycle( uint8_t duty ){
//	/* duty can be a value between 0% and 100% */
//	if( duty <= 100 )
//		return (( duty / 100.0 )*( TIM3->ARR + 1));
//	else
//		return 0;
//}


void USER_TIM3_Delay( uint16_t prescaler, uint16_t maxCount ){
	TIM3->PSC = prescaler;
	TIM3->ARR = maxCount;
	TIM3->SR &= ~( 0x1UL << 0U );
	TIM3->CR1 |= ( 0x1UL << 0U );
	while(!(TIM3->SR & ( 0x1UL << 0U )));
	TIM3->CR1 &= ~( 0x1UL << 0U );
}
