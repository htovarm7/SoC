#include <stdint.h>
#include "main.h"
#include "user_tim.h"

// void USER_TIM3_PWM_Init( void ){
// 	/* STEP 0. Enable the clock signal for the TIM3 and GPIOB peripherals */
// 	RCC->IOPENR		|=  ( 0x1UL <<  1U );
// 	RCC->APBENR1	|=  ( 0x1UL <<  1U );

// 	/* STEP 0. Configure TIM3_CH1 (PB4) to output the PWM signal */
// 	GPIOB->AFRL		&= ~( 0xEUL << 16U );
// 	GPIOB->AFRL		|=  ( 0x1UL << 16U );
// 	GPIOB->PUPDR  &= ~( 0x3UL <<  8U );
// 	GPIOB->OTYPER	&= ~( 0x1UL <<  4U );
// 	GPIOB->MODER  &= ~( 0x1UL <<  8U );
// 	GPIOB->MODER  |=  ( 0x2UL <<  8U );

// 	/* STEP 1. Configure the clock source (internal) */
// 	TIM3->SMCR		&= ~( 0x1UL << 16U )
// 					&  ~( 0x7UL <<  0U );//		Prescaler is clocked directed by the internal clock

// 	/* STEP 2. Configure the counter mode, the auto-reload and the overflow UEV-event  */
// 	TIM3->CR1			&= ~( 0x3UL <<  5U ) //		Selects edge-aligned mode
// 						&  ~( 0x1UL <<  4U ) //		Counter used as upcounter
// 						&  ~( 0x1UL <<  2U ) //		UEV can be generated by software
// 						&  ~( 0x1UL <<  1U );//		Update Event (UEV) enabled
// 	TIM3->CR1			|=  ( 0x1UL <<  7U );//		Auto-reload register is buffered

// 	/* STEP 3. Configure the prescaler, the period and the duty cycle register values */
// 	TIM3->PSC			 = 0U;
// 	TIM3->ARR			 = 47999U;//	for 1 KHz frequency
// 	TIM3->CCR1		 = USER_Duty_Cycle( 25 );//	for 25% of duty cycle

// 	/* STEP 4. Configure the PWM mode, the compare register load and channel direction */
// 	TIM3->CCMR1		&= ~( 0x1UL << 16U )
// 					&  ~( 0x1UL <<  4U ) //		Selects PWM 1 mode
// 					&  ~( 0x3UL <<  0U );//		Selects CH1 as output

//  	TIM3->CCMR1		|=  ( 0x6UL <<  4U ) //		Selects PWM 1 mode
// 					|   ( 0x1UL <<  3U );//		CCR1 loads on the UEV event

// 	/* STEP 5. Generate the UEV-event to load the registers */
// 	TIM3->EGR		|=  ( 0x1UL <<  0U );

// 	/* STEP 6. Enable the PWM signal output and set the polarity */
// 	TIM3->CCER		&= ~( 0x1UL <<  3U ) //		for output mode, this bit must be cleared
// 					&  ~( 0x1UL <<  1U );//		OC1 active high
// 	TIM3->CCER		|=  ( 0x1UL <<  0U );//		OC1 signal is output on the corresponding pin

// 	/* STEP 7. Enable the Timer to start counting */
// 	TIM3->CR1		|=  ( 0x1UL <<  0U );
// }

void USER_TIM3_PWM_4CH_Init( void ){
	/* STEP 0. Enable the clock signal for the TIM3 and GPIOB peripherals */
	RCC->IOPENR		|=  ( 0x1UL <<  1U );
	RCC->APBENR1	|=  ( 0x1UL <<  1U );
	/* STEP 0.
	 * Configure TIM3_CH1 (PB4) to output the PWM signal */
	GPIOB->AFRL		&= ~( 0xEUL << 16U );
	GPIOB->AFRL		|=  ( 0x1UL << 16U );
	GPIOB->PUPDR  	&= ~( 0x3UL <<  8U );
	GPIOB->OTYPER	&= ~( 0x1UL <<  4U );
	GPIOB->MODER  	&= ~( 0x1UL <<  8U );
	GPIOB->MODER  	|=  ( 0x2UL <<  8U );
	/* Configure TIM3_CH2 (PB5) to output the PWM signal */
	GPIOB->AFRL		&= ~( 0xEUL << 20U );
	GPIOB->AFRL		|=  ( 0x1UL << 20U );
	GPIOB->PUPDR  	&= ~( 0x3UL << 10U );
	GPIOB->OTYPER	&= ~( 0x1UL <<  5U );
	GPIOB->MODER  	&= ~( 0x1UL << 10U );
	GPIOB->MODER  	|=  ( 0x2UL << 10U );
	/* Configure TIM3_CH3 (PB0) to output the PWM signal */
	GPIOB->AFRL		&= ~( 0xEUL <<  0U );
	GPIOB->AFRL		|=  ( 0x1UL <<  0U );
	GPIOB->PUPDR  	&= ~( 0x3UL <<  0U );
	GPIOB->OTYPER	&= ~( 0x1UL <<  0U );
	GPIOB->MODER  	&= ~( 0x1UL <<  0U );
	GPIOB->MODER  	|=  ( 0x2UL <<  0U );
	/* Configure TIM3_CH4 (PB1) to output the PWM signal */
	GPIOB->AFRL		&= ~( 0xEUL <<  4U );
	GPIOB->AFRL		|=  ( 0x1UL <<  4U );
	GPIOB->PUPDR  	&= ~( 0x3UL <<  2U );
	GPIOB->OTYPER	&= ~( 0x1UL <<  1U );
	GPIOB->MODER  	&= ~( 0x1UL <<  2U );
	GPIOB->MODER  	|=  ( 0x2UL <<  2U );
	/* STEP 1. Configure the clock source (internal) */
	TIM3->SMCR		&= ~( 0x1UL << 16U )
					&  ~( 0x7UL <<  0U );//		Prescaler is clocked directed by the internal clock
	/* STEP 2. Configure the counter mode, the auto-reload and the overflow UEV-event  */
	TIM3->CR1		&= ~( 0x3UL <<  5U ) //		Selects edge-aligned mode
					&  ~( 0x1UL <<  4U ) //		Counter used as upcounter
					&  ~( 0x1UL <<  2U ) //		UEV can be generated by software
					&  ~( 0x1UL <<  1U );//		Update Event (UEV) enabled
	TIM3->CR1		|=  ( 0x1UL <<  7U );//		Auto-reload register is buffered
	/* STEP 3. Configure the prescaler, the period and the duty cycle register values */
	TIM3->PSC		= 0U;
	TIM3->ARR		= 47999U;//					for 1 KHz frequency
	TIM3->CCR1		= 0U;//						for 0% of duty cycle in CH1
	TIM3->CCR2		= 0U;//						for 0% of duty cycle in CH2
	TIM3->CCR3		= 0U;//						for 0% of duty cycle in CH3
	TIM3->CCR4		= 0U;//						for 0% of duty cycle in CH4
	/* STEP 4. Configure the PWM mode, the compare register load and channel direction */
	TIM3->CCMR1		&= ~( 0x1UL << 24U )
					&  ~( 0x1UL << 12U ) //		Selects PWM 1 mode for CH2
					&  ~( 0x1UL << 16U )
					&  ~( 0x1UL <<  4U ) //		Selects PWM 1 mode for CH1
					&  ~( 0x3UL <<  8U ) //		Selects CH2 as output
					&  ~( 0x3UL <<  0U );//		Selects CH1 as output
	TIM3->CCMR1		|=  ( 0x6UL << 12U ) //		Selects PWM 1 mode for CH2
					|   ( 0x1UL << 11U ) //		CCR2 loads on the UEV event
					|   ( 0x6UL <<  4U ) //		Selects PWM 1 mode for CH1
					|   ( 0x1UL <<  3U );//		CCR1 loads on the UEV event
	TIM3->CCMR2		&= ~( 0x1UL << 24U )
					&  ~( 0x1UL << 12U ) //		Selects PWM 1 mode for CH4
					&  ~( 0x1UL << 16U )
					&  ~( 0x1UL <<  4U ) //		Selects PWM 1 mode for CH3
					&  ~( 0x3UL <<  8U ) //		Selects CH4 as output
					&  ~( 0x3UL <<  0U );//		Selects CH3 as output
	TIM3->CCMR2		|=  ( 0x6UL << 12U ) //		Selects PWM 1 mode for CH4
					|   ( 0x1UL << 11U ) //		CCR4 loads on the UEV event
					|   ( 0x6UL <<  4U ) //		Selects PWM 1 mode for CH3
					|   ( 0x1UL <<  3U );//		CCR3 loads on the UEV event
	/* STEP 5. Generate the UEV-event to load the registers */
	TIM3->EGR		|=  ( 0x1UL <<  0U );
	/* STEP 6. Enable the PWM signal output and set the polarity */
	TIM3->CCER		&= ~( 0x1UL << 15U ) //		for CH4 output mode, this bit must be cleared
					&  ~( 0x1UL << 13U ) //		OC4 active high
					&  ~( 0x1UL << 11U ) //		for CH3 output mode, this bit must be cleared
					&  ~( 0x1UL <<  9U ) //		OC3 active high
					&  ~( 0x1UL <<  7U ) //		for CH2 output mode, this bit must be cleared
					&  ~( 0x1UL <<  5U ) //		OC2 active high
					&  ~( 0x1UL <<  3U ) //		for CH1 output mode, this bit must be cleared
					&  ~( 0x1UL <<  1U );//		OC1 active high
	TIM3->CCER		|=  ( 0x1UL << 12U ) //		OC4 signal is output on the corresponding pin
					|   ( 0x1UL <<  8U )//		OC3 signal is output on the corresponding pin
					|   ( 0x1UL <<  4U )//		OC2 signal is output on the corresponding pin
					|   ( 0x1UL <<  0U );//		OC1 signal is output on the corresponding pin
	/* STEP 7. Enable the Timer to start counting */
	TIM3->CR1		|=  ( 0x1UL <<  0U );
}


void update_cycle(uint8_t duty){
	TIM3->CCR1		 = USER_Duty_Cycle( duty );//	for 25% of duty cycle
	TIM3->CCR2		 = USER_Duty_Cycle( duty );//	for 25% of duty cycle
	TIM3->CCR3		 = USER_Duty_Cycle( duty );//	for 25% of duty cycle
	TIM3->CCR4		 = USER_Duty_Cycle( duty );//	for 25% of duty cycle

}

uint16_t USER_Duty_Cycle( uint8_t duty ){
	/* duty can be a value between 0% and 100% */
	if( duty <= 100 )
		return (( duty / 100.0 )*( TIM3->ARR + 1));
	else
		return 0;
}

void USER_TIM3_Delay( uint16_t prescaler, uint16_t maxCount ){
	/* STEP 3. Configure the prescaler and the maximum count */
	TIM3->PSC = prescaler;
	TIM3->ARR = maxCount;
	/* STEP 4. Clear the Timer Update Interrupt Flag */
	TIM3->SR &= ~( 0x1UL << 0U );
	/* STEP 5. Enable the Timer to start counting */
	TIM3->CR1 |= ( 0x1UL << 0U );
	/* STEP 6. Wait for the Overflow */
	while(!(TIM3->SR & ( 0x1UL << 0U )));
	/* STEP 7. Disable the Timer to stop counting */
	TIM3->CR1 &= ~( 0x1UL << 0U );
}

void USER_TIM17_Init(void)
{
    RCC->APBENR2 |= (0x1UL << 18U);
    TIM17->CR1 = 0;
    TIM17->PSC = 48 - 1;
    TIM17->ARR = 0xFFFF;
    TIM17->CR1 |= (0x1UL << 0U);
}

void TIM17_Delay_ms(uint16_t delay_ms)
{
    uint16_t start = TIM17->CNT;
    uint16_t ticks = delay_ms * 1000;  // 1 ms = 1000 ticks (a 1 MHz)

    while ((uint16_t)(TIM17->CNT - start) < ticks);
}
